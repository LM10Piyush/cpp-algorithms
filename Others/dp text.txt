***************************** BASICS********************************************
IN DP: Dp is all about caching the data(function calls), or you can say, when I can build the bigger solution 
using smaller solution such that subproblem "overlapp" and also holds the "optimal substructure". It doesn't matter, problem involves
trying all possiblity or not, you can do it using dp, if above condition holds then you can do it using DP. But mostly you see
that people are solving those questions in which we have to try all possiblity and greedy fails, then we feels, it is the time to try all 
possibilites. Dp needs only above mentioned conditions.
Thats why the important part of the dp is recurrence relation. To learn the dp, you have to think, 
does it hold "optimal substructure" and "overlapping subproblem" then DEFINE DP using states, then think
how you are going to pass states from one to another one(transitions), then make the recurrence relation.

0) What do you need to find (clear in mind).
1) optimal substructure.
2) overlapping subproblem.
3) DEFINE DP using states.
4) how you are going to pass states from one to another one(transitions)
5) make the recurrence relation (final and most important stage).
6) Code it using TOP down or bottom up.

NOTE: when subproblems doesn't overlapp then, it comes under into the divide and conqure paradigm. 

In dp: If you want the best solution for 'i', can you get it using j such that (j < i). 
Formally, calculating bigger states using smaller ones.

Finding the bigger state, you have to compute for smaller state.
## EX: For Matrix: Thus to find the best solution for that cell(i, j), we have to have already found the 
 best solutions for all of the cells from which we can arrive to the current cell.
EX: e Min[i][j] , which represents the length of the shortest path found to vertex i, with j money being left.


##When have read the description of a problem and started to solve it, first look at its restrictions. 
If a polynomial-time algorithm should be developed, then it’s possible that the solution may be of DP type. 
In this case try to see if there exist such states (sub-solutions) with the help of which the next states (sub-solutions) may be found. 
Having found that – think about how to pass from one state to another. If it seems to be a DP problem, 
but you can’t define such states, then try to reduce the problem to another one

##3Points:
1) Optimal Substructure.
2) Overlapping sub-problem (sub-solutions).
3) How to pass from one state to another.


In dp, you have to build the solution from smaller problem to bigger problem.
During building the solution, at every moment, I have a choice, should I use the
current option or should I use the best result I got till previous option. And
then, I compare for best result for that problem. This is called building the solution.
You can reach to the solution of larger problem without using smaller problem.
SOME examples: https://codeforces.com/blog/entry/43256
		https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/
		https://www.youtube.com/watch?v=4T2wQ5LGmWg&list=PLcBc1Yp8mZQdFzQ0H2bvyiJ35fwVX0pl4&index=2
*For finding a state i, we need to first find all smaller states j (j<i). 

So, the process is like this:
	1) Identify the  states.
	2) Build for the base case.
	3) After base case, at every moment, you have use the current option
	or you don't use the current option and use till the previous option, 
	and in this way you pick the best result.
	4) In dp, it does not depend how deep an state repeats, because if it depends then it must
	be included in the state. EX: In fibonacci state tree, it does not depend on the depth of the same
	function call, it only depends on the recursive call.

*************************************TOP down & Bottm Up *********************************************
In top-down dp, we don't need to do extra stuff, all things will be done by recursion
and memoization. But in bottom-up, you have to run expilcitly and carefully using loops. In both recurrence relation
is approx same, but the movement from on state to another will vary little bit.

** f(current state) = f(next state) // top down recurrence, in this we first hit the base case becuz "next state" is not known yet, 
Here we are driving the CURRENT STATE using the NEXT STATE, it method known as topdown. EX: https://pastebin.com/JYBcxbzu
** f(current state) = f(previous state) // bottom up, find the current state using previous state.

There could be two Push dp and Pull dp. In push-dp we fill the next state from current state via only valid move(s),
in pull dp, we fill the current state using previous state via only valid moves(s).  
Bottom up Pull dp: f(current state) = f(previous state) // finding the current state using the previous state.
Bottom up Push dp: f(next state) = f(current state) // finding the next state using the current state(already known).


************************************* DEFINE DP *******************************************************
**In dp, one of the most important thing is to DEFINE THE DP STATE, what is representing what
in the states, how you you gonna move. You have to DEFINE THE DP[i][j]... correctly.

In dp, we have a condition and then find the best solution according to the condition.
We have 2-ways to do this:
1) Build the solution by considering the condition, then find the best solution,
   eg: https://codeforces.com/contest/1353/problem/E
2) Build the solution by not considering the condition then, find the best solution
   by considering the considering. https://codeforces.com/contest/1077/problem/F1
Above two ways, depends on question to question.


*********************************************** EXample****************************************
Ex: In knapsack, dp[i][j] => using elements from [1...i], the maximum value I can get if I have weight 'j',
				to do this job correctly, I have create recurrence relation, based on "use it" or "not" current one
				on the basis of this, we can try all the possiblity and get the max value.
				dp[i][j] = max(dp[i-1][j], value[i] + dp[i-1][j-weigh[i]]), or max(don't include, include current)



**************************************** Game Theory **********************************************
Mostly in game theory we start builiding the solution from the end of the game to start of the game (bottom up),
So that, one should choose the best option.


************************************* NOTE******************************************************
#If you are not able to come up with recurrence relation, then try brute force and see what it does, it helps in two ways
   a) Answer will be correct. 
   b) The same recurrence relation which is used in brute force can be used in the recurrence relation for dp
	because they are same(begginners are little bit good in brute force :).
   Then, then define/meaning to the states, Ex: f(i, j) => will give the best result for subarray [i...j] by observing the 
	recursion.
	HENCE, donot underestimate the brute force, it will give you recurrence relation if you are not able to come up with it directly.
	Once you become pro in dp, then you can it easily.

# Another Most important Tip to come up with *BOTTOM UP* solution: Please prefer to write the recurrence relation in this way 
	1st method => f(i...) = f(i-1....) instead of 2nd method => f(i..) = f(i+1...)
	because in the first method, you can easily come up with the bottom up solution, I'm not saying that you cannot come up with the 
	bottom up solution with the second method, you can do, but for begginers it is little bit hard to see the bases case for large values
	of states. To do this, think the about the brute force solution(recursive) starts from [N...1], or f(N)=> f(N-1)... f(base). In this
	way you get the base where all the calculations begins and value of states are less becuz states are decreasing. 
	I mentioned this, becuz most people applies the recursion in this way f(1) => f(2) => f(N) (base case), and you hit a base case, 
	at this point the value of the state is high, and it is hard to see it for beginners. Thats why, you can bottom up solution of fibonacci,
	lines of wines etc problems etc, because you can see their recurrence relation in 1st type easily.
	Ex: for knapsack, 1st method => f(i, w) = max(f(i-1, w), f(i-1, value[i] + w - weight[i])  [moving up 1.....N]
			  2nd method => f(i, w) = max(f(i+1, w), f(i+1, value[i] + w-weight[i])) //this is more intitutive for begginer but try
				the above one, this makes bottom up easy to see.
	As you noticed that, both methods are same only the movement is changed, Ex: for LCS if you try to build using 1st method then you get 
	your ans at dp[n][m] becuze for base case will be at (0, 0)(when both strings are empty), but for 2nd method, your ans will be at dp[1][1](just reversed of previous method),
 	becuz base case will be at (n+1, m+1)(both will be empty).
	
	Here donot confuse with the which one should be use for top down up and which one for bottom up both are compatible with both method, 
        becuz top down and bottom depend how you start to construct the soluion, top down if f(current state) => f(next state) (which not calculated yet).
	Bottom up f(current state) = f(previous state). Bottom up is moving from already calculated to next state.
	now current state could be i & previous could i+1, or current could be i  and next could be i-1, it only depends on how you approches the problem,
	both the methods can do top down and bottom up, But here we are discussing the bottom up as you can see the heading. 
	And to come up easily(as begginner) you should create the recurrence in 1st way.

************************************* So Mind you technique and habits to solve problems *************************************
##Quick same thing: most people: try to do recurrence like this fun(0) and base  if(i >=n ) { }, 
	so recurrene will be like this fun(i..) = fun(i+1...),
 	so here it is easy to see top down but hard to see bottom up, becuz base case is i == n, then it little bit hard to see and build from 
	that base case to build the whole soon. So try to make recurrence like this: f(n), if(i == 0) {base} , now recurrence will be 
	like this f(i...) = f(i-1...) now it is easy to see the bottom up here. We just need to change the point of view to change the recurrence.
	So make the recurrence such that you are moving from high state to low state, then bottom up leads you to make solution from lower state to
	higher state.
	OR we can say, instead of moving from source to destination in the mentioned path(eg, right, down), prefer  to move from destination 
	to source to reverse path(left, up). Ex: https://atcoder.jp/contests/dp/submissions/14411476
						https://atcoder.jp/contests/dp/submissions/14399464 
	Here I used the 2nd method(f(i..)=f(i+1...)) of recurrence, becz, for that question it is easy to implement, so I have to go from last and 
	then go up, As I told you, using both method of recurrence you can come up with bottom up and top down. topdown is little simpler because
	you have to move as ques said, but in bottom up, you have to just opposite of it. 
	EX: using 2nd method of reccurence: https://pastebin.com/v9FkC6Y5 
	Ex: LCS using both recurrences: https://atcoder.jp/contests/dp/submissions/14428752 | https://atcoder.jp/contests/dp/submissions/14399464

**TIP**: I will choose that recurrence method for bottom up on which I can iterate easily and imagine easily. You get the bottom up solution when made 
	the recurrence relation and you are able to think how recursion goes how base case hits and how it comes back from recursion, or we can say
	our recursion is well organised and you can predict how things goes, but there is many cases when you are not able to do imagine that:
	Ex; dp with bitmask, here you cannot predict how thing goes, because there is no fixed mannner of recursion. 
	Ex: http://lightoj.com/volume_showproblem.php?problem=1005 | soln(https://pastebin.com/tGNAVSUp) (here is the only way to do it is topdown, 
	becz it is hard to imagine how thing goes becz there every time we have to check that configuration is right or not, we have no such technique to get always right configuration).
	
	So, mostly in such situations when you don't imagine or predict how recursion goes in a fixed way, then there is only way to do it is by top-down.

Forms of DP:
1) Normal some contribution technique.
2) Standard DP 1D/2D on array or strings
3) Digit DP
4) DP with bitmask
5) DP on trees / graphs
6) Sum over subsets DP(SOS)
7) Matrix exponentiation


Problems for DP:
https://codeforces.com/problemset/problem/894/A
https://codeforces.com/contest/490/problem/C (Hacking Cypher)
https://codeforces.com/contest/550/problem/C (divisiblity by eight)
https://codeforces.com/contest/877/problem/B
https://codeforces.com/contest/327/problem/A (Flipping game, dP)
https://codeforces.com/contest/1140/problem/D (Mininum Triangulation)
https://codeforces.com/problemset/problem/414/B (B. Mashmokh and ACM) complexity: O(nklog(n))
https://codeforces.com/contest/166/problem/E (Tetrahedron)
https://www.codechef.com/problems/DELISH  (Delish, dp)
https://codeforces.com/contest/1005/problem/D (Polycarp and div3)
https://codeforces.com/contest/1221/problem/D (Make that fence great again)
https://codeforces.com/contest/120/problem/F (spiders) {in-out tree dp}
https://codeforces.com/contest/44/problem/E (Ansifa the monkey)
https://codeforces.com/contest/1257/problem/D  (yet another monster killing problem)
https://codeforces.com/contest/1130/problem/C (Div2: C Connect)
https://codeforces.com/contest/920/problem/E (connected components)
https://codeforces.com/contest/220/problem/B (Little elephant and array, MO, sqrt)
https://codeforces.com/blog/entry/55274 (A blog with all ques with topic wise)
https://cses.fi/problemset/ for problems  (problem set, DP soln: https://codeforces.com/blog/entry/70018 )
https://codeforces.com/contest/1081/problem/C (combinators with dp)
https://www.codechef.com/LTIME60A/problems/SHIFTPAL (hashing like rabin karp, Important ques, with its editorial){https://www.codechef.com/submit/complete/32359239}
https://codeforces.com/contest/264/problem/B (Good sequences DP)
https://www.codechef.com/problems/KANYASAI ( digit dp, soln: https://www.codechef.com/viewsolution/29212253)
https://atcoder.jp/contests/dp/tasks/dp_s (digit dp, soln: https://atcoder.jp/contests/dp/submissions/14598857)
https://www.hackerearth.com/problem/algorithm/playing-with-digits-4e25844f/ (digit dp)
https://codeforces.com/contest/817/problem/C (binary search, Really big numbers)
https://codeforces.com/contest/888/problem/D (maths, derangements)
https://www.hackerearth.com/problem/algorithm/happy-segments-e290faa6/description/  (Happy segments, MO)
https://atcoder.jp/contests/abc165/submissions/12734276 (dp, LIS, graph)
https://codeforces.com/contest/1208/problem/D  (segtree with dp)
https://www.hackerrank.com/challenges/robot/problem (segTree with DP, sol: https://pastebin.com/q9jip5X0)
https://codeforces.com/contest/977/problem/F (dp, LIS, Maths)
https://codeforces.com/contest/1353/problem/E (dp + good implementation)
https://codeforces.com/contest/1077/problem/F1 (dp)
https://codeforces.com/contest/566/problem/F (dp, LIS, Maths, Sieve)
https://codeforces.com/contest/1350/problem/B (DP, LIS, MAths, sieve)
https://codeforces.com/contest/264/problem/B (DP, LIS, Maths, Sieve, O(nlogn), becuz, n < 1e6, max_element <= 1e7)
https://leetcode.com/problems/largest-divisible-subset/  (DP, LIS, O(n2) solution needed becuz, max_element <= 2e9, n < 6e3) 
https://codeforces.com/contest/562/problem/E (convex hull)
https://codeforces.com/contest/660/problem/C (dp + binary search)
https://codeforces.com/contest/768/problem/B (divide n Conquer)
https://codeforces.com/problemset/problem/1111/C (divide n conquer)
FIND LARGEST SUM SUBARRAY IN ARRAY USING DnC
https://codeforces.com/problemset/problem/835/C
https://www.hackerrank.com/contests/all-india-contest-by-coding-club-india-30-may-2020/challenges/ritesh-first-love/problem (Maths, difference Formula)
https://atcoder.jp/contests/agc044/tasks/agc044_a (Divisors DP, soln : https://atcoder.jp/contests/agc044/submissions/14012427)
https://cses.fi/problemset/task/1633  (DP, dice, soln: https://pastebin.com/J5JrqnC7)
https://cses.fi/problemset/task/1634   (DP, coin change, https://pastebin.com/vFKgWicG)
https://cses.fi/problemset/task/1633 (DP, https://pastebin.com/rLsLFTpC)
https://codeforces.com/contest/1056/problem/D (tree dp)
https://www.codechef.com/problems/CHEFZRON (dp, sol: https://www.codechef.com/viewsolution/34059249)
https://cses.fi/problemset/task/1652  (DP, 2D matrix Prefix sum, soln: https://pastebin.com/DUnJcQ4P)
https://codeforces.com/contest/835/problem/C  (DP, 2D matrix Prefix sum, soln: https://codeforces.com/contest/835/submission/82290525)
https://arena.topcoder.com/#/u/practiceCode/1239/1209/1259/1/1239  (Zig-zag, soln; https://pastebin.com/AhQ5ApTF)
https://leetcode.com/problems/maximal-square/ (Maximum squares of 1's)
https://leetcode.com/problems/partition-equal-subset-sum/ (DP, looks like 3D, but must done in 2D, Soln(TOP DOWN): https://pastebin.com/JYBcxbzu, BOTTOM UP: https://pastebin.com/tVn0DR83)
https://cses.fi/problemset/task/1745  (Same problem as above(partition-equal-subset-sum) we have to check which sums I can make using the coins)
https://cses.fi/problemset/task/1093  (Same as above problem with fermat little theorem)
https://codeforces.com/problemset/problem/859/C  (DP, Game theory)
http://lightoj.com/volume_showproblem.php?problem=1011 (DP with bitmask, solN: https://pastebin.com/j1v4eTZ9)
https://www.spoj.com/problems/EPALIN/ (DP, edit distance)
https://cses.fi/problemset/task/1097  (DP, game theory, SOLN: https://pastebin.com/ZZSeZbrJ)
http://lightoj.com/volume_showproblem.php?problem=1031    (DP, Game theory, https://pastebin.com/xUEjseJ6, SAME AS ABOVE PROBLEM)
https://www.hackerrank.com/challenges/sherlock-and-cost/problem  (Important DP, with some greedyness to avoid overcalculation, sol: https://pastebin.com/7yk2CHDp) 
https://cses.fi/problemset/task/1746  (Must Do DP, Combinatorics ques, Learn how to push the number of ways)
https://www.hackerrank.com/challenges/construct-the-array/problem (DP, combo)
https://atcoder.jp/contests/dp/tasks/dp_i  (DP, Probability, Binomial Coeff, https://atcoder.jp/contests/dp/submissions/14509284)
https://www.hackerrank.com/challenges/sam-and-substrings/problem  (DP, Contribution Technique, Implemetation, SOL: https://pastebin.com/bth2PuZZ)
https://practice.geeksforgeeks.org/contest-problem/tie-the-poles-in-pairs/0/  (DP, Catalan Number)









