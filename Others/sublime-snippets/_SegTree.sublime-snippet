<snippet>
	<content><![CDATA[
//Range min
template <typename T>
struct SegTree{
  vector <T> tree;
  int n; 

  SegTree(vector<T> &A){
    n = sz(A);
    tree.assign(4*n, 0);
    build(A, 0, n-1, 1);
  }

  void build(vector<T>&A, int lo, int hi, int node){
    if(lo == hi){
      tree[node] = A[lo];
      return;
    }
    int mid = (lo + hi) / 2;
    build(A, lo, mid, 2*node);
    build(A, mid+1, hi, 2*node+1);
    tree[node] = min(tree[2*node], tree[2*node+1]);
  }

  void upd(int idx, T val, int lo, int hi, int node){
    // no overlapp
    if(hi < idx or lo > idx) return;
    //total overlapp
    if(lo == hi and hi == idx){
      tree[node] = val;
      return;
    }

    int mid = (lo + hi) / 2;
    upd(idx, val, lo, mid, 2*node);
    upd(idx, val, mid+1, hi, 2*node+1);
    tree[node] = min(tree[2*node], tree[2*node+1]);
  }

  void upd(int idx, T val){   //update at value at index 'idx' to 'val'
    upd(idx, val, 0, n-1, 1);
  }

  T qry(int l, int r, int lo, int hi, int node){
    //no overlapp
    if(hi < l or lo > r) return 1e9;
    //total overlapp
    if(l <= lo and hi <= r){
      return tree[node];
    }
    int mid = (lo + hi) / 2;
    return min(qry(l, r, lo, mid, 2*node), qry(l, r, mid+1, hi, 2*node+1));
  }

  T qry(int l, int r){  //query [l...r]
    return qry(l, r, 0, n-1, 1);
  }
};

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>_SegTree</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
