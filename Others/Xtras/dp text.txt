***************************** BASICS********************************************
DP: says how we can use the already calculated things and then build the ans for bigger ones, so just break the problem into its smaller sub-problem (recursively) and build the answer for bigger problems from smaller ones. Ex: power Exponentation, 0/1 knapsack etc.

========================================== IN SHORT ==========================================================
MainConcept of DP is to build the answer from already calculated small problems, or I can say that by RECURRENCE relation because meaning is same. 
By writing recurrence means breaking down the problem into similar smaller subproblem. Then in implement that recurrence in efficient manner. Here you are bulding the 
solution from the base states to bigger states. You can implement it efficiently by Top-down approach (memoization) and Bottom up approch (iterative version). 

So, in the end you can say DP is just a efficient recursion.

Tip: If you are not able to think reccurrence, then start from simple cases then solve for bigger one.
To build recurrence you need: understanding of problem, defining DP[states..] and states, dependencies and there should not be any self dependency that means
to calculte dp[i][j] we to solve dp[i][j] like: dp[i][j] = dp[i][j] + dp[i-1][j].

DP on DAG is also a intresting way.


***************************** How to choose state?? ********************************
What is a state: State means what information defines your problem, suppose your state is index 'i' i.e., dp[i], that means you problems depends on index 'i'. Sometimes you need more information to store to define you problem solution correctly.

How to chose it???  
Just choose state in such a way, what information is need you to keep track of. There are bunch of information, some of which are independent some are depend, but what information you need to keep track of to solve the problem and it is mandatory. ex: in knapsack we need to keep track of the "current weight of the bag", and "just previous state", so that we can build the answer for current state.

===========================================================================================================

IN DP: Dp is all about caching the data(function calls), or you can say, when I can build the bigger solution 
using smaller solution such that subproblem "overlapp" and also holds the "optimal substructure". It doesn't matter, problem involves
trying all possiblity or not, you can do it using dp, if above condition holds then you can do it using DP. But mostly you see
that people are solving those questions in which we have to try all possiblity and greedy fails, then we feels, it is the time to try all 
possibilites. Dp needs only above mentioned conditions.
Thats why the important part of the dp is recurrence relation. To learn the dp, you have to think, 
does it hold "optimal substructure" and "overlapping subproblem" then DEFINE DP using states, then think
how you are going to pass states from one to another one(transitions), then make the recurrence relation.

0) What do you need to find (clear in mind).
1) optimal substructure.
2) overlapping subproblem.
3) DEFINE your DP using states like dp[i][j] => max profit achieved by using 1..n numbers and j items are taken.
4) how you are going to pass states from one to another one(transitions)
5) make the recurrence relation (final and most important stage).
6) Code it using TOP down or bottom up.
7) Optional: You might have to optimize your implementation by DP optimization.

NOTE: when subproblems doesn't overlapp then, it comes under into the divide and conqure paradigm. 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TiP: During using Bottom up DP, try to use if else condition to not go at invalid states.
Ex: https://codeforces.com/contest/673/submission/109453651 
better: https://codeforces.com/contest/673/submission/109455040
Little bit more: https://codeforces.com/contest/673/submission/109455202 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In dp: If you want the best solution for 'i', can you get it using j such that (j < i). 
Formally, calculating bigger states using smaller ones.

Finding the bigger state, you have to compute for smaller state.
## EX: For Matrix: Thus to find the best solution for that cell(i, j), we have to have already found the 
 best solutions for all of the cells from which we can arrive to the current cell.
EX: e Min[i][j] , which represents the length of the shortest path found to vertex i, with j money being left.


##When have read the description of a problem and started to solve it, first look at its restrictions. 
If a polynomial-time algorithm should be developed, then it’s possible that the solution may be of DP type. 
In this case try to see if there exist such states (sub-solutions) with the help of which the next states (sub-solutions) may be found. 
Having found that – think about how to pass from one state to another. If it seems to be a DP problem, 
but you can’t define such states, then try to reduce the problem to another one

##3Points:
1) Optimal Substructure.
2) Overlapping sub-problem (sub-solutions).
3) How to pass from one state to another (transitions).

++++++++++++++++++++++++++++ Transition ++++++++++++++++++++++++++++++++++++++++++++
Suppose you have given a situation where we have to do some operations. Analyse the problem create the states. 
Now how to make transitions, transition means going from one state to another to calculate the answer for bigger problems
from answer of smaller sub-problems. To do that, just see what operations you have to do, ex: in knapsack we have to pick the item and put it inside the bag OR just skip that item, so we have these two types of operations in knapsack. These 
operations will give the way how to make transition. 

In knapsack, state: dp[i][sum] :using elements [1..n], and current weight in bag is 'sum' 
In top-down way: 
 skip the current item: dp[i+1][sum]
 use current item: dp[i+1][sum + weight[i]] + value[i]

In bottom up: 
 skip the current item: dp[i-1][sum]
 use current item: dp[i-1][sum - weight[i]] + value[i]

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In dp, you have to build the solution from smaller problem to bigger problem.
During building the solution, at every moment, I have a choice, should I use the
current option or should I use the best result I got till previous option. And
then, I compare for best result for that problem. This is called building the solution.
You can reach to the solution of larger problem without using smaller problem.
SOME examples: https://codeforces.com/blog/entry/43256
		https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/
		https://www.youtube.com/watch?v=4T2wQ5LGmWg&list=PLcBc1Yp8mZQdFzQ0H2bvyiJ35fwVX0pl4&index=2
*For finding a state i, we need to first find all smaller states j (j<i). 

So, the process is like this:
	1) Identify the  states. (state defines current situation)
	2) Build for the base case.
	3) After base case, at every moment, you have use the current option
	or you don't use the current option and use till the previous option, 
	and in this way you pick the best result.
	4) In dp, it does not depend how deep an state repeats, because if it depends then it must
	be included in the state. EX: In fibonacci state tree, it does not depend on the depth of the same
	function call, it only depends on the recursive call.


++++++++++++++++++++++++++++++++++++ NOTE +++++++++++++++++++++++++++++++++++++++++++++++
Important thing in dp state, suppose we have any state, eg: dp[i][sum], now this state is independent of order of
previous operations, that means it doesn't matter what choices we have make previously, it only matters how to reach to the current state from previous state.
ex: dp[10][24], it doesn't matter how we have elements used or in which order elements are used to calculate previous states like dp[9][10] or dp[8][4] etc. It only matters how we are reaching to our current state from previous state.

ex: like in Travelling salesman, where state is dp[mask], if mask: 101101101 => it doesn't matter how traversed previous states like: 101100001, 100011101, 100001001 etc, only thing which matters is what how to reach current state from previous one.

If your solution depends on order, then it is not dp, because every time order changes, so does the state, never state repeat. 

So, yeah this is important insight, during formulation of DP.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


*************************************TOP down & Bottm Up *********************************************
In top-down dp, we don't need to do extra stuff, all things will be done by recursion
and memoization. But in bottom-up, you have to run expilcitly and carefully using loops. In both recurrence relation
is approx same, but the movement from on state to another will vary little bit.

** f(current state) = f(next state) // top down recurrence, in this we first hit the base case becuz "next state" is not known yet, 
Here we are driving the CURRENT STATE using the NEXT STATE, it method known as topdown. EX: https://pastebin.com/JYBcxbzu
** f(current state) = f(previous state) // bottom up, find the current state using previous state.

There could be two Push dp and Pull dp. In push-dp we fill the next state from current state via only valid move(s),
in pull dp, we fill the current state using previous state via only valid moves(s).  
Bottom up Pull dp: f(current state) = f(previous state) // finding the current state using the previous state.
Bottom up Push dp: f(next state) = f(current state) // finding the next state using the current state(already known).

To solve dp problem: 1st step should be to prove that it is a dp problem. Find its states (states should not be less or more, these should be accurate),
the find recurrence relation.

In topdown: just implment the recurence relation and memoise it.

In Bottom up: After finding recurrence relation. Be careful while running loops, you should move from lower states to higher states OR to calculate smaller
states first then higher states using bigger states (by reccurrence relation). 

********************************************* Process in a Nutshell *******************************************
To solve dp problem: 1st step should be to prove that it is a dp problem. Find its states (states should not be less or more, these should be accurate),
then give some meaning or definition to that state, then find recurrence relation or transition between states (smaller problems to bigger).

In topdown: just implment the recurence relation and memoise it.

In Bottom up: After finding recurrence relation. Be careful while running loops, you should move from lower states to higher states OR to calculate smaller
states first then higher states using bigger states (by reccurrence relation). 

*************************************Memory efficient and time efficient*****************************************
* Bottom up helps to optimize the dp solution because it is our responsiblity to run it itertively, like ye can apply segment tree, stacks to update
the states efficiently. We can use less memory also, via excluding one of the state. Ex: IN knapsack probably you have to done knapsack without including
the index the current element, becuz we only need the previous state to update the current state, so no need to store whole 'n'states data, just use
dp[2][W] in 0/1 knapsack. This type of memory trick helps you to solve many problems, it is quite common we just need previous state so no need to store 
the data of whole 'n' elements

************************************* DEFINE DP *******************************************************
**In dp, one of the most important thing is to DEFINE THE DP STATE, what is representing what
in the states, how you you gonna move. You have to DEFINE THE DP[i][j]... correctly.

In dp, we have a condition and then find the best solution according to the condition.
We have 2-ways to do this:
1) Build the solution by considering the condition, then find the best solution,
   eg: https://codeforces.com/contest/1353/problem/E
2) Build the solution by not considering the condition then, find the best solution
   by considering the considering. https://codeforces.com/contest/1077/problem/F1
Above two ways, depends on question to question.


*********************************************** EXample****************************************
Ex: In knapsack, dp[i][j] => using elements from [1...i], the maximum value I can get if I have weight 'j',
				to do this job correctly, I have create recurrence relation, based on "use it" or "not" current one
				on the basis of this, we can try all the possiblity and get the max value.
				dp[i][j] = max(dp[i-1][j], value[i] + dp[i-1][j-weigh[i]]), or max(don't include, include current)



**************************************** Game Theory **********************************************
Mostly in game theory, we first see the common winning point can someone prune to other (most 1st player prunes second), we start builiding the 
solution from the end of the game to start of the game (bottom up), So that, one should choose the best option. 


************************************* NOTE******************************************************
#If you are not able to come up with recurrence relation, then try brute force and see what it does, it helps in two ways
   a) Answer will be correct. 
   b) The same recurrence relation which is used in brute force can be used in the recurrence relation for dp
	because they are same(begginners are little bit good in brute force :).
   Then, then define/meaning to the states, Ex: f(i, j) => will give the best result for subarray [i...j] by observing the 
	recursion.
	HENCE, donot underestimate the brute force, it will give you recurrence relation if you are not able to come up with it directly.
	Once you become pro in dp, then you can it easily.

# Another Most important Tip to come up with *BOTTOM UP* solution: Please prefer to write the recurrence relation in this way 
	1st method => f(i...) = f(i-1....) instead of 2nd method => f(i..) = f(i+1...)
	because in the first method, you can easily come up with the bottom up solution, I'm not saying that you cannot come up with the 
	bottom up solution with the second method, you can do, but for begginers it is little bit hard to see the bases case for large values
	of states. To do this, think the about the brute force solution(recursive) starts from [N...1], or f(N)=> f(N-1)... f(base). In this
	way you get the base where all the calculations begins and value of states are less becuz states are decreasing. 
	I mentioned this, becuz most people applies the recursion in this way f(1) => f(2) => f(N) (base case), and you hit a base case, 
	at this point the value of the state is high, and it is hard to see it for beginners. Thats why, you can bottom up solution of fibonacci,
	lines of wines etc problems etc, because you can see their recurrence relation in 1st type easily.
	Ex: for knapsack, 1st method => f(i, w) = max(f(i-1, w), f(i-1, value[i] + w - weight[i])  [moving up 1.....N]
			  2nd method => f(i, w) = max(f(i+1, w), f(i+1, value[i] + w-weight[i])) //this is more intitutive for begginer but try
				the above one, this makes bottom up easy to see.
	As you noticed that, both methods are same only the movement is changed, Ex: for LCS if you try to build using 1st method then you get 
	your ans at dp[n][m] becuze for base case will be at (0, 0)(when both strings are empty), but for 2nd method, your ans will be at dp[1][1](just reversed of previous method),
 	becuz base case will be at (n+1, m+1)(both will be empty).
	
	Here donot confuse with the which one should be use for top down up and which one for bottom up both are compatible with both method, 
        becuz top down and bottom depend how you start to construct the soluion, top down if f(current state) => f(next state) (which not calculated yet).
	Bottom up f(current state) = f(previous state). Bottom up is moving from already calculated to next state.
	now current state could be i & previous could i+1, or current could be i  and next could be i-1, it only depends on how you approches the problem,
	both the methods can do top down and bottom up, But here we are discussing the bottom up as you can see the heading. 
	And to come up easily(as begginner) you should create the recurrence in 1st way.

************************************* So Mind your technique and habits to solve problems *************************************
##Quick same thing: most people: try to do recurrence like this fun(0) and base  if(i >=n ) { }, 
	so recurrene will be like this fun(i..) = fun(i+1...),
 	so here it is easy to see top down but hard to see bottom up, becuz base case is i == n, then it little bit hard to see and build from 
	that base case to build the whole soon. So try to make recurrence like this: f(n), if(i == 0) {base} , now recurrence will be 
	like this f(i...) = f(i-1...) now it is easy to see the bottom up here. We just need to change the point of view to change the recurrence.
	So make the recurrence such that you are moving from high state to low state, then bottom up leads you to make solution from lower state to
	higher state.
	OR we can say, instead of moving from source to destination in the mentioned path(eg, right, down), prefer  to move from destination 
	to source to reverse path(left, up). Ex: https://atcoder.jp/contests/dp/submissions/14411476
						https://atcoder.jp/contests/dp/submissions/14399464 
	Here I used the 2nd method(f(i..)=f(i+1...)) of recurrence, becz, for that question it is easy to implement, so I have to go from last and 
	then go up, As I told you, using both method of recurrence you can come up with bottom up and top down. topdown is little simpler because
	you have to move as ques said, but in bottom up, you have to just opposite of it. 
	EX: using 2nd method of reccurence: https://pastebin.com/v9FkC6Y5 
	Ex: LCS using both recurrences: https://atcoder.jp/contests/dp/submissions/14428752 | https://atcoder.jp/contests/dp/submissions/14399464

**TIP**: I will choose that recurrence method for bottom up on which I can iterate easily and imagine easily. You get the bottom up solution when made 
	the recurrence relation and you are able to think how recursion goes how base case hits and how it comes back from recursion, or we can say
	our recursion is well organised and you can predict how things goes, but there is many cases when you are not able to do imagine that:
	Ex; dp with bitmask, here you cannot predict how thing goes, because there is no fixed mannner of recursion. 
	Ex: http://lightoj.com/volume_showproblem.php?problem=1005 | soln(https://pastebin.com/tGNAVSUp) (here is the only way to do it is topdown, 
	becz it is hard to imagine how thing goes becz there every time we have to check that configuration is right or not, we have no such technique to get always right configuration).
	
	So, mostly in such situations when you don't imagine or predict how recursion goes in a fixed way, then there is only way to do it is by top-down.

Quick Tip for DP for how to think the transition: suppose you are at dp[i][j], now you have to go to the dp[i+1][j], dp[i][j] => dp[i+1][j] then think how you will go,
	similarly, if you are dp[i][j], now you have to go the dp[i+1][j+1] then how you go... dp[i][j] => dp[i+1][j+1].


Forms of DP:
1) Normal some contribution technique, it may also include dp on expected number.
2) Standard DP 1D/2D on array or strings
3) Digit DP
4) DP with bitmask
5) DP on trees (tree dp / rerooting) / graphs 
6) Sum over subsets DP(SOS)
7) Matrix exponentiation or Exponentiation DP
8) Dp in some order (exchange arguments or sorting) when problem depends on the order of them items, becuz in DP, we include the item to the solution or not, so this
   forms a subsequence of the items and as we know subsequence is order dependent. Normally if problem doesn't require the order then we don't need to do 
   sorting with some comparator  https://codeforces.com/blog/entry/63533.
9)  Dp with data structures like Fenwick tree, SegTree
10) Space saving dp like knapsack with 2-D array
11) Dp optimizations: Convex hull (Lichao tree), DnC optimization, Knuth morris optimization, FFT optimization
12) Some Bon-trival dp tricks by zscoder codeforces.
13) DP on graphs (like Travelling Salesman, Hamiltonion cycle) (https://codeforces.com/blog/entry/337).
14) DP with stack, Envelop like structure. It is like Dp with some greediness to skip some elements greedily, mostly implemented by Stack like Next Greater element on Left.

User: LM10_Piyush on Codeforces/ Hackerrank
DP optimizations: https://codeforces.com/blog/entry/8219

https://codeforces.com/blog/entry/67679
Problems for DP:
https://codeforces.com/problemset/problem/894/A
https://codeforces.com/contest/490/problem/C (Hacking Cypher)
https://codeforces.com/contest/550/problem/C (divisiblity by eight)
https://codeforces.com/contest/877/problem/B
https://leetcode.com/problems/product-of-array-except-self/ (DP, basic prefix-suffix product problem)
https://codeforces.com/contest/327/problem/A (Flipping game, dP)
https://codeforces.com/contest/1140/problem/D (Mininum Triangulation)
https://codeforces.com/problemset/problem/414/B (B. Mashmokh and ACM) complexity: O(nklog(n))
https://codeforces.com/contest/166/problem/E (Tetrahedron)
https://www.codechef.com/problems/DELISH  (Delish, dp)
https://codeforces.com/contest/1005/problem/D (Polycarp and div3)
https://codeforces.com/contest/1221/problem/D (Make that fence great again)
https://codeforces.com/contest/120/problem/F (spiders) {in-out tree dp}
https://codeforces.com/contest/44/problem/E (Ansifa the monkey)
https://codeforces.com/contest/1257/problem/D  (yet another monster killing problem)
https://codeforces.com/contest/1130/problem/C (Div2: C Connect)
https://codeforces.com/contest/920/problem/E (connected components)
https://codeforces.com/contest/220/problem/B (Little elephant and array, MO, sqrt)
https://codeforces.com/blog/entry/55274 (A blog with all ques with topic wise)
https://cses.fi/problemset/ for problems  (problem set, DP soln: https://codeforces.com/blog/entry/70018 )
https://codeforces.com/contest/1081/problem/C (combinators with dp, https://codeforces.com/contest/1081/submission/78104503)
https://www.codechef.com/LTIME60A/problems/SHIFTPAL (hashing like rabin karp, Important ques, with its editorial){https://www.codechef.com/submit/complete/32359239}
https://codeforces.com/contest/264/problem/B (Good sequences DP)
https://www.codechef.com/problems/KANYASAI ( digit dp, soln: https://www.codechef.com/viewsolution/29212253)
https://atcoder.jp/contests/dp/tasks/dp_s (digit dp, soln: https://atcoder.jp/contests/dp/submissions/14598857)
https://www.hackerearth.com/problem/algorithm/playing-with-digits-4e25844f/ (digit dp)
https://codeforces.com/contest/817/problem/C (binary search, Really big numbers)
https://codeforces.com/contest/888/problem/D (maths, derangements)
https://www.hackerearth.com/problem/algorithm/happy-segments-e290faa6/description/  (Happy segments, MO)
https://atcoder.jp/contests/abc165/submissions/12734276 (dp, LIS, graph)
https://codeforces.com/contest/1208/problem/D  (segtree with dp)
https://www.hackerrank.com/challenges/robot/problem (segTree with DP, sol: https://pastebin.com/q9jip5X0)
https://codeforces.com/contest/977/problem/F (dp, LIS, Maths)
https://codeforces.com/contest/1353/problem/E (dp + good implementation, K-Gaps)
https://codeforces.com/contest/1282/problem/B2 (Dp, K-gaps (mod traversal), soln: https://codeforces.com/contest/1282/submission/75436172)
https://codeforces.com/contest/1077/problem/F1 (dp, Picture with kittens, (not memory optimized)top-down: https://codeforces.com/contest/1077/submission/86706951, better solution with less states: https://codeforces.com/contest/1077/submission/104257710, another way to write recurrence and may be better: https://codeforces.com/contest/1077/submission/104258452)
https://codeforces.com/contest/566/problem/F (dp, LIS, Maths, Sieve)
https://atcoder.jp/contests/abc177/tasks/abc177_e  (Dp, sieve, think like graphs, https://atcoder.jp/contests/abc177/submissions/16637688)
https://codeforces.com/contest/1350/problem/B (DP, LIS, MAths, sieve)
https://codeforces.com/contest/264/problem/B (DP, LIS, Maths, Sieve, O(nlogn), becuz, n < 1e6, max_element <= 1e7)
https://leetcode.com/problems/largest-divisible-subset/  (DP, LIS, O(n2) solution needed becuz, max_element <= 2e9, n < 6e3) 
https://codeforces.com/contest/562/problem/E (convex hull)
https://codeforces.com/contest/660/problem/C (dp + binary search)
https://codeforces.com/contest/768/problem/B (divide n Conquer)
https://codeforces.com/problemset/problem/1111/C (divide n conquer)
FIND LARGEST SUM SUBARRAY IN ARRAY USING DnC
https://leetcode.com/problems/climbing-stairs/  (Basic DP, fibonacci)
https://leetcode.com/problems/min-cost-climbing-stairs/ (DP, fibo, https://pastebin.com/mLjsZ6Yz)
https://leetcode.com/problems/divisor-game/  (DP, factors, https://pastebin.com/5E8c3cvE)
https://leetcode.com/problems/unique-paths/  (Dp, matrix)
https://codeforces.com/problemset/problem/835/C
https://www.hackerrank.com/contests/all-india-contest-by-coding-club-india-30-may-2020/challenges/ritesh-first-love/problem (Maths, difference Formula)
https://atcoder.jp/contests/agc044/tasks/agc044_a (Divisors DP, soln : https://atcoder.jp/contests/agc044/submissions/14012427)
https://cses.fi/problemset/task/1633  (DP, dice, soln: https://pastebin.com/J5JrqnC7)
https://cses.fi/problemset/task/1634   (DP, coin change, https://pastebin.com/vFKgWicG)
https://cses.fi/problemset/task/1633 (DP, https://pastebin.com/rLsLFTpC)
https://codeforces.com/contest/1056/problem/D (tree dp)
https://www.codechef.com/problems/CHEFZRON (dp, sol: https://www.codechef.com/viewsolution/34059249)
https://cses.fi/problemset/task/1652  (DP, 2D matrix Prefix sum, soln: https://pastebin.com/DUnJcQ4P)
https://codeforces.com/contest/835/problem/C  (DP, 2D matrix Prefix sum, soln: https://codeforces.com/contest/835/submission/82290525)
https://arena.topcoder.com/#/u/practiceCode/1239/1209/1259/1/1239  (Zig-zag, soln; https://pastebin.com/AhQ5ApTF)
https://leetcode.com/problems/maximal-square/ (Maximum squares of 1's)
https://leetcode.com/problems/partition-equal-subset-sum/ (DP, looks like 3D, but must done in 2D, Soln(TOP DOWN): https://pastebin.com/JYBcxbzu, BOTTOM UP: https://pastebin.com/tVn0DR83)
https://cses.fi/problemset/task/1745  (Same problem as above(partition-equal-subset-sum) we have to check which sums I can make using the coins)
https://cses.fi/problemset/task/1093  (Same as above problem with fermat little theorem)
https://codeforces.com/problemset/problem/859/C  (DP, Game theory)
https://www.hackerrank.com/contests/all-india-contest-by-mission-helix-a-31-october/challenges/0-1-alternate-substrings  (0-1 alternate substrings, basic dp count, https://pastebin.com/9y0Mzs4J)
http://lightoj.com/volume_showproblem.php?problem=1011 (DP with bitmask, solN: https://pastebin.com/j1v4eTZ9)
https://www.spoj.com/problems/EPALIN/ (DP, edit distance)
https://cses.fi/problemset/task/1097  (DP, game theory, SOLN: https://pastebin.com/ZZSeZbrJ)
http://lightoj.com/volume_showproblem.php?problem=1031    (DP, Game theory, https://pastebin.com/xUEjseJ6, SAME AS ABOVE PROBLEM)
https://www.hackerrank.com/challenges/sherlock-and-cost/problem  (Important DP, with some greedyness to avoid overcalculation, sol: https://pastebin.com/7yk2CHDp) 
https://cses.fi/problemset/task/1746  (Must Do DP, Combinatorics ques, Learn how to push the number of ways, and we fill the number of ways in level wise i = 1,2,3..N)
https://www.hackerrank.com/challenges/construct-the-array/problem (DP, combo)
https://atcoder.jp/contests/dp/tasks/dp_i  (DP, Probability, Binomial Coeff, https://atcoder.jp/contests/dp/submissions/14509284)
https://www.hackerrank.com/challenges/sam-and-substrings/problem  (DP, Contribution Technique, Implemetation, SOL: https://pastebin.com/bth2PuZZ)
https://practice.geeksforgeeks.org/contest-problem/tie-the-poles-in-pairs/0/  (DP, Catalan Number)
https://leetcode.com/problems/perfect-squares/  (Dp, same as coins)
https://www.codechef.com/COCA2020/problems/COCA2006  (DP, similar as stars and bars, Simple TLE idea: https://pastebin.com/epFrZCdE, Now same idea with optimization:https://pastebin.com/QRTK24B4)
                                          NOTE: To do these type of combinatorics problems move in level wise i.e., i=>[1...N]
https://codeforces.com/problemset/problem/1081/C  (DP, combinatorics, soln: https://codeforces.com/contest/1081/submission/85494616)
https://www.codechef.com/AFZQ2019/problems/REVT  (DP, Combo, https://www.codechef.com/viewsolution/34902660)
https://codeforces.com/problemset/problem/891/A  (DP, soln: https://codeforces.com/contest/891/submission/88044487)
https://codeforces.com/problemset/problem/1215/B  (Similar prefix, https://codeforces.com/contest/1215/submission/85720559)
https://www.hackerrank.com/challenges/fair-cut/problem (DP, Contribution,state reduction, modulus, https://pastebin.com/tG1r9kJf) 
https://www.hackerrank.com/challenges/summing-pieces/problem (Contribution, DP, see Discussion section, sol: https://pastebin.com/xkiZGmLh)
https://pastebin.com/henHgJzw  (Problem statment written in it, Bitmask)
https://codeforces.com/problemset/problem/1196/D2  (Dp, prefix sum colors, https://codeforces.com/contest/1196/submission/87753164)
https://codeforces.com/contest/455/problem/A  (DP, Boredom, https://codeforces.com/contest/455/submission/86103014)
https://www.geeksforgeeks.org/ways-to-arrange-balls-such-that-adjacent-balls-are-of-different-types/
https://cses.fi/problemset/task/1744      (DP, rectangles, sol: https://pastebin.com/qWSMUsEj)
https://codeforces.com/contest/474/problem/D (DP, Combonatorics Pruning, soln: https://codeforces.com/contest/474/submission/86503889)
https://codeforces.com/contest/466/problem/C  (DP, counts)
https://codeforces.com/contest/1095/problem/C  (dp, greedy, factors, https://codeforces.com/contest/1095/submission/89653975)
https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff08/0000000000387174 (DP, soln:  https://pastebin.com/xSYptKBu)
https://codeforces.com/contest/1324/problem/E (Dp, push DP, bottom up: sol: https://codeforces.com/contest/1324/submission/86696444)
https://codeforces.com/problemset/problem/1077/F1  (DP, IMPortant, top-down Noob soln: https://codeforces.com/contest/1077/submission/86823851, bottom up; https://codeforces.com/contest/1077/submission/87681349)
https://codeforces.com/contest/118/problem/D (Dp, IMportant, soln with 5-states https://codeforces.com/contest/118/submission/88017341, soln with 4-states, no need of previous pointer https://codeforces.com/contest/118/submission/88039429, solution with 3-states: https://codeforces.com/contest/118/submission/88041215)
https://codeforces.com/problemset/problem/71/C (DP, factors, soln: https://codeforces.com/contest/71/submission/88047862)
https://codeforces.com/problemset/problem/1288/C  (DP, Stars and bars, Combinatorial, https://codeforces.com/contest/1288/submission/88074818)
https://codeforces.com/problemset/problem/339/C  (Dp or DFS, normal problem 3-states, Top-down solN : https://codeforces.com/contest/339/submission/88120178)
https://codeforces.com/contest/176/problem/B  (DP, IMP, LOOKs like O(K*N) space, but done it in O(k), one point to NOte, we can run in O(K*N), but that much memory is not possible, we use trick to store less(O(k)) and run O(N*K).
					see how Shifting/ cutting, Long long gives TLE, thats why you need bottom up- soln: https://codeforces.com/contest/176/submission/88136469)
https://codeforces.com/contest/279/problem/C  (DP, observation increasing decreasing https://codeforces.com/contest/279/submission/88157238)
https://codeforces.com/problemset/problem/294/B (dp greedy,soln https://codeforces.com/contest/294/submission/88221749)
https://codeforces.com/problemset/problem/909/C (DP, Top-down but TLE https://codeforces.com/contest/909/submission/88226865, bottom-up but TLE https://codeforces.com/contest/909/submission/88229565
                                       no top-down possible(I guess)(bottom-up efficient : https://codeforces.com/contest/909/submission/88232558, bottom-up clean cod with suffix sum : https://codeforces.com/contest/909/submission/88232849)

https://leetcode.com/problems/minimum-path-sum/ (simple dp on matrix problem, min of up & right)
https://codeforces.com/problemset/problem/519/D  (DP, map+prefix sum, https://codeforces.com/contest/519/submission/88265231)
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ (DP, top-down, https://pastebin.com/v2sndhee)
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/  (DP, stocks with cooldown, top-down, https://pastebin.com/r7iyur9J)
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ (DP, top-down, https://pastebin.com/k0xYCkHk)
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ (DP, top-down, https://pastebin.com/h4Zs9UWF, bottom-up https://pastebin.com/SMxTa7Ys)
https://codeforces.com/problemset/problem/1286/A (DP, greedy, greedy soln: https://codeforces.com/contest/1286/submission/88371451)
https://leetcode.com/problems/word-break/ (DP, top-down soln: https://pastebin.com/b90ppyvQ, bottom-up: https://pastebin.com/tLeuvZN6)
https://leetcode.com/problems/word-break-ii/  (DP, top-down, backtracking, https://pastebin.com/wRNB3zFW)
https://leetcode.com/problems/dungeon-game/  (DP + greedy)
https://leetcode.com/problems/concatenated-words/  (Dp, similar to word break, top-down https://pastebin.com/M8wa2gDu)
https://codeforces.com/problemset/problem/1327/E  (DP, contribution, combinatorics, https://codeforces.com/contest/1327/submission/88621589)
https://leetcode.com/problems/maximum-product-subarray/  (DP, like Kadane in products, https://pastebin.com/yXr2z80y)

Sometimes you are not able apply TOP-down solution because of memory issue ie., we not able to create such large array, if we implement that problem in
bottom up then, we can element one state which is the index of current element, becuz it obvious by the loop which element we are currently on, and to
update the dp state we just need the previous state ie., dp[i-1] mostly. Same concept used in memory efficent 0/1 knapsack and then state becomes dp[2][W].
You might see some problem like Pascal triangle where loop run O(n2) and space O(n2), but after reducing the space becuz we only need the nth binomial coeff
O(n2) run time and O(n) memory space.

https://codeforces.com/problemset/problem/543/A (DP, important, Combinatorics, top-down TLE, bottom up runs good, memory efficient by skipping the current element state, https://codeforces.com/contest/543/submission/88694641)
https://codeforces.com/contest/1117/problem/D  (DP, Matrix Expo, https://codeforces.com/contest/1117/submission/88867254)
https://codeforces.com/contest/1391/problem/D    (Dp with bitmask, https://codeforces.com/contest/1391/submission/89592858)
https://leetcode.com/problems/pascals-triangle-ii/  (Pascal triangle, https://pastebin.com/9EsVcqyd , in O(n2) and O(n) extra space, this trick helps  in dp problems when we just need few previous rows to calculate
           the data of the current row, so no need to store the whole data, just use the columns alternatively.
https://codeforces.com/contest/1294/problem/D  (Important, Mex-maximizing, greedy-dp, Modulus, https://codeforces.com/contest/1294/submission/89787447)
https://codeforces.com/contest/1165/problem/E   (Greedy-dp, Contribution, Sorting, https://codeforces.com/contest/1165/submission/89827636)
https://codeforces.com/contest/1398/problem/C  (Good subarray, Trick: subarray could be written as prefix sum, count the subarrays, https://codeforces.com/contest/1398/submission/89965926)
https://codeforces.com/contest/1398/problem/D   ( Colored Rectangles, Dp, top-down: https://codeforces.com/contest/1398/submission/89994904, bottom-up: https://codeforces.com/contest/1398/submission/89997174)

************************************** DP with exchange arguments *********************************
https://ki.staszic.waw.pl/task.php?name=bombki    (Christmas balls, actually boxes, problem is in polish (activate the Google translate), I hope the solution is correct, Top down with map: https://pastebin.com/dhnaZucG)
https://codeforces.com/contest/1401/problem/D    (Maximum Distributed Tree, DP, contribution techniq, greedy, soln: https://codeforces.com/contest/1401/submission/90882209)
https://codeforces.com/contest/1203/problem/F2            (Bottom up: https://codeforces.com/contest/1203/submission/112877763, top down: https://codeforces.com/contest/1203/submission/112877029)

**********************************************************************************************
https://leetcode.com/problems/minimum-cost-for-tickets/    (Dp, top-down https://pastebin.com/ZrDUftBf)
https://codeforces.com/contest/1400/problem/D  (Dp, counting, Contribution, map, https://codeforces.com/contest/1400/submission/91001206)
https://www.hackerearth.com/problem/algorithm/weird-number-e7dc0051/   (Digit-dp, https://pastebin.com/jAiqXvns)
https://codeforces.com/contest/1400/problem/B  (RPG Protagonist, Smart brute force, becuz there is no greedy way, but have some greedyness, https://codeforces.com/contest/1400/submission/91162502)

https://leetcode.com/problems/partition-to-k-equal-sum-subsets/  (dp: https://pastebin.com/HJ3XsXaD, constraints are low, Brute force solution, https://pastebin.com/a6yYD0VG)
https://www.codechef.com/PRACTICE/problems/CIRMERGE       (Circular Merge, Same as Matrix chain Multiplication, (by doubling the array) https://www.codechef.com/viewsolution/37386387, (by just using mod) https://www.codechef.com/viewsolution/37387318)
https://codeforces.com/contest/846/problem/C   (Four Segments, dp, smart bruteforce, https://codeforces.com/contest/846/submission/91525432)
https://codeforces.com/contest/1409/problem/F  (Subsequences of Length Two, dp, top-down, https://codeforces.com/contest/1409/submission/91890655)

https://codeforces.com/contest/1197/problem/D (Yet Another Subarray Problem, Yet Another Subarray Problem, https://codeforces.com/contest/1197/submission/93055691)
https://www.codechef.com/problems/BULBS   (greedy,  like knapsack, smart bruteforce, https://www.codechef.com/viewsolution/38080854)

https://codeforces.com/contest/453/problem/B  (Little Pony and Harmony Chest, DP with bitmask, Gerate the solution array, compression cordinates, top-down: https://codeforces.com/contest/453/submission/95014465, bottom up: https://codeforces.com/contest/453/submission/95014402)
https://codeforces.com/contest/1427/problem/C  (The Hard Work of Paparazzi, observation greedy trick, https://codeforces.com/contest/1427/submission/95159252)
https://codeforces.com/contest/1036/problem/C  (Classy Numbers, digit dp, top-down: https://codeforces.com/contest/1036/submission/95498710, bottom up: https://codeforces.com/contest/1036/submission/95501389, bottom up with memory optimized: https://codeforces.com/contest/1036/submission/95527462)
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/  (Best Time to Buy and Sell Stock IV, tight time limit and memory, topdown (memory error): https://pastebin.com/0NPep6ic, (bottom-up)(memory error) https://pastebin.com/jhYsEKn7, (bottom up with memory optimised) https://pastebin.com/FcRAMFGR)

/************************************* Expected Value ****************************************************************
https://atcoder.jp/contests/dp/tasks/dp_j
https://atcoder.jp/contests/dp/tasks/dp_i                   (probability)
https://codeforces.com/contest/1187/problem/F
https://codeforces.com/contest/846/problem/F
https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff08/0000000000386edd
https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d8565     (Probability)
https://codingcompetitions.withgoogle.com/kickstart/round/00000000001a0069/0000000000415054#problem
https://atcoder.jp/contests/abc184/tasks/abc184_d   (Expected value, https://atcoder.jp/contests/abc184/submissions/18829434)
https://atcoder.jp/contests/abc189/tasks/abc189_f
https://codeforces.com/contest/518/problem/D              (Easy, expected value, dp, https://codeforces.com/contest/518/submission/109504798)
https://codeforces.com/contest/697/problem/D              (Trees, expected value, https://codeforces.com/contest/697/submission/110061186)
https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec28e       (Doubles, max expected value, generate answer, Implementation tricky, https://pastebin.com/jniMaXHH, bottom up: https://pastebin.com/wR7SGCvH)
/******************************************************************************************************

https://codeforces.com/contest/1433/problem/F  (Zero remainder sum, modulus, DP on matrix, like knapsack, top-down: https://codeforces.com/contest/1433/submission/96314904, bottom up: https://codeforces.com/contest/1433/submission/96382463)
https://codeforces.com/contest/1084/problem/C  (The Fair Nut and String, Combinatorics, Maths trick, Important, https://codeforces.com/contest/1084/submission/96390657)
https://leetcode.com/problems/max-dot-product-of-two-subsequences/  (same as LCS, top-down: https://pastebin.com/8Vh7hXiC, bottom-up https://pastebin.com/eJbKqUgJ)
https://leetcode.com/problems/stone-game-iv/   (Basic dp, game theory, https://pastebin.com/DMwW7Gzq)
https://leetcode.com/problems/stone-game/   (Minimax dp, game thoery, Trival solution, soln: return true)
https://codeforces.com/contest/52/problem/B   ( Right Triangles, prefix matrix sum, combinatorics, https://codeforces.com/contest/52/submission/96801646)
https://codeforces.com/contest/1034/problem/A   ( Enlarge GCD, maths, seive, https://codeforces.com/contest/1034/submission/96812902)
https://codeforces.com/contest/1437/problem/C  (Chef Monocarp, sorting dp, greediness, top-down: https://codeforces.com/contest/1437/submission/96932273,  bottom-up: https://codeforces.com/contest/1437/submission/96932623)
https://www.codechef.com/problems/SUBMEXS   (Chef and Subtree MEXs, Tree-dp, https://www.codechef.com/viewsolution/39248243	)
https://www.hackerrank.com/contests/all-india-contest-by-mission-helix-a-31-october/challenges/maximum-sum-tree/copy-from/1327850404  (Maximum Sum Tree,Tree DP, https://pastebin.com/NtCvEcad)
https://leetcode.com/problems/binary-tree-maximum-path-sum/  (Tree dp, https://pastebin.com/zbibabtj)
https://codeforces.com/problemset/problem/212/E         (IT restraunts, dp, https://codeforces.com/gym/306738/submission/101103248)
https://atcoder.jp/contests/abc185/tasks/abc185_e  (Sequence Matching, like LCS or Edit distance, top-down sol: https://atcoder.jp/contests/abc185/submissions/18771904, bottom-up : https://atcoder.jp/contests/abc185/submissions/18771958)
https://www.codechef.com/PBK22020/problems/ITGUY24  (DP, knapsack, combinatorics, smart trick, top down: ***, bottom up: https://www.codechef.com/viewsolution/40679126, bottom up memory efficient: https://www.codechef.com/viewsolution/40679190)
https://atcoder.jp/contests/abc186/tasks/abc186_d      (prefix sum, contribution,modulous, https://atcoder.jp/contests/abc186/submissions/18877396)
https://leetcode.com/problems/decode-ways/             (DP, like fibonacci, https://pastebin.com/v9TEsCsb)
https://leetcode.com/problems/decode-ways-ii/            (DP, hard version, https://pastebin.com/E7CXV4Fa)
https://codeforces.com/contest/1427/problem/C           (DP, with optimizations, don't need to iterate over all states, https://codeforces.com/contest/1427/submission/95159252)
https://codeforces.com/contest/505/problem/C           (DP, with optimizations, don't need to iterate over all states, https://codeforces.com/contest/505/submission/102960440)
https://atcoder.jp/contests/abc183/tasks/abc183_e      (Dp on matrix, optimization with prefix sum, https://atcoder.jp/contests/abc183/submissions/19184557)
https://atcoder.jp/contests/abc187/tasks/abc187_f     (Dp, smart method to iterate over the subsets of mask, Important, Article: https://cp-algorithms.com/algebra/all-submasks.html, https://atcoder.jp/contests/abc187/submissions/19172462)
https://atcoder.jp/contests/abc188/tasks/abc188_e        (dp, DAG, graph, https://atcoder.jp/contests/abc188/submissions/19340914)
https://atcoder.jp/contests/abc188/tasks/abc188_f       (dp, maths, factor, map, important, https://atcoder.jp/contests/abc188/submissions/19355471, https://atcoder.jp/contests/abc188/submissions/19333200)
https://atcoder.jp/contests/abc180/tasks/abc180_e       (dp, travelling salesman, https://atcoder.jp/contests/abc180/submissions/19308700)
https://codeforces.com/contest/321/problem/E           (dp, divide and conqure optimization, fast input, https://codeforces.com/contest/321/submission/104367056)
https://codeforces.com/contest/1077/problem/F2       (dp, optimization with some techinique, Divide and conqure optimization : https://codeforces.com/contest/1077/submission/104366757)
https://leetcode.com/problems/count-sorted-vowel-strings/          (dp, string in sorted order, not a knapsack but useful, https://pastebin.com/bn9cYjh1)
https://leetcode.com/problems/burst-balloons/            (dp, IMPortant, range, trick in Defining the DP, important, https://pastebin.com/bUFypJTQ)
https://leetcode.com/problems/longest-palindromic-subsequence/       (DP, longest palindrome subsequcence, Important, break the problem in this way that such that is always palindromic, https://pastebin.com/xNtbUWDR)
https://leetcode.com/problems/longest-palindromic-substring/         (DP, longest palindrome substring, Important, https://pastebin.com/GAez0bwr)
https://codeforces.com/contest/1459/problem/D                        (DP, like knapsack, important, tricky, memory strict, only bottom up possible: https://codeforces.com/contest/1459/submission/104761236 (efficient than 2-vectors), 2-vectors(less efficient): https://codeforces.com/contest/1459/submission/104722194)
https://codeforces.com/contest/1000/problem/D                     (DP, combinatorics, a bit tricky at first, Observe carefull how STATE is chosen it like LIS, bottom up: https://codeforces.com/contest/1000/submission/104885557, top-down: https://codeforces.com/contest/1000/submission/104884282)
https://cses.fi/problemset/task/1140                              (DP, like LIS, interval, sorting, binary search, Observe how we have picked the state, https://pastebin.com/XL5i6kkT)
https://codeforces.com/contest/1223/problem/D                 (DP, like LIS, maintaining sequence, intervals, set tricks, https://codeforces.com/contest/1223/submission/104982087)
https://cses.fi/problemset/task/1130                        (tree dp, tree edges, cool dp problem, tree-matching, https://pastebin.com/V85rFfYz) 
https://codeforces.com/contest/1223/problem/E        (Paint the Tree, extension of Tree matching problem, Exchange arguments, tree dp)
https://codeforces.com/contest/1474/problem/D         (dp (simple), observation, greedy, https://codeforces.com/contest/1474/submission/105066577)
https://codeforces.com/contest/1144/problem/G        (dp, greedy (possible), https://codeforces.com/contest/1144/submission/105457887)
https://www.spoj.com/problems/DCOWS/                           (Dp, sorting, like knapsack, https://pastebin.com/STciuKfV)
https://codeforces.com/contest/710/problem/E                (Greedy, dp, Like Dijkstra's, DAG, https://codeforces.com/contest/710/submission/105645950)
https://codeforces.com/contest/864/problem/E           (Dp, like knapsack, building the answer, sorting, https://codeforces.com/contest/864/submission/105663711)
https://codeforces.com/contest/577/problem/B               (DP, modulo, maths, https://codeforces.com/contest/577/submission/105778994)
https://codeforces.com/contest/5/problem/C               (Longest valid parenthesis, brackets, https://codeforces.com/contest/5/submission/105786755)
https://codeforces.com/contest/607/problem/B            (DP, kind of MCM, palindrome substring, https://codeforces.com/contest/607/submission/105788794)
https://codeforces.com/contest/1475/problem/G             (DP, LIS, https://codeforces.com/contest/1475/submission/105398683)
https://codeforces.com/contest/1476/problem/C           (DP, https://codeforces.com/contest/1476/submission/105946375)
https://codeforces.com/contest/463/problem/D               (Graph, DP, DAG, permutation, LCS, https://codeforces.com/contest/463/submission/106107524)
https://codeforces.com/contest/510/problem/D              (maths, dp, diaphotine equation, gcd, https://codeforces.com/contest/510/submission/106225574)
https://leetcode.com/problems/trim-a-binary-search-tree/
https://atcoder.jp/contests/dp/tasks/dp_n                   (Like matrix chain multiplication, DP, https://atcoder.jp/contests/dp/submissions/19915760)
https://atcoder.jp/contests/dp/tasks/dp_o                    (Bitmask dp, time-optimization, top-down: https://atcoder.jp/contests/dp/submissions/19916194, bottom up TLE: https://atcoder.jp/contests/dp/submissions/19916456, bottom up optimized: https://atcoder.jp/contests/dp/submissions/19919165, with memory optimized: https://atcoder.jp/contests/dp/submissions/19919492)
https://atcoder.jp/contests/dp/tasks/dp_p                      (Tree dp, basic counting, https://atcoder.jp/contests/dp/submissions/19922830)
https://codeforces.com/contest/1065/problem/D                (dp, matrix, chess, https://codeforces.com/contest/1065/submission/107002300)
https://codeforces.com/contest/1155/problem/D               (dp, like kadane, top down: https://codeforces.com/contest/1155/submission/107114694, bottom up: https://codeforces.com/contest/1155/submission/107166824)
https://codeforces.com/contest/1452/problem/D               (dp, like fibonacci, https://codeforces.com/contest/1452/submission/107174417)
https://codeforces.com/contest/597/problem/C               (dp, combinatorics, fenwick tree, data structure, https://codeforces.com/contest/597/submission/107186179)
https://codeforces.com/contest/1077/problem/F2           (DP, with segment tree and got MLE, https://codeforces.com/contest/1077/submission/110535196)
https://codeforces.com/contest/946/problem/D                   (DP, string, precompute + optimize, https://codeforces.com/contest/946/submission/107049436)
https://codeforces.com/contest/628/problem/D                   (DP on digit, tricky, https://codeforces.com/contest/628/submission/107072882)
https://atcoder.jp/contests/abc180/tasks/abc180_e               (dp on graphs, travelling salesman, topdown: https://atcoder.jp/contests/abc180/submissions/19308700, bottom up: https://atcoder.jp/contests/abc180/submissions/21348937)
https://www.codechef.com/LTIME94A/problems/CODON             (DP on grah, Nice observation other than DP, https://www.codechef.com/viewsolution/44308432)
https://codeforces.com/contest/11/problem/D                (DP on graph, Important DP state, https://codeforces.com/contest/11/submission/111456686)
https://codeforces.com/contest/1313/problem/C2                 (Monotonic stack, greedy, datastructure, Envelop type structure (like area under histogram), https://codeforces.com/contest/1313/submission/112107300)
https://leetcode.com/problems/largest-sum-of-averages/                (DP, Quite standard dp state like CF div 3: Kittens and picture problem, https://pastebin.com/66KYCkX8)
https://codeforces.com/contest/1096/problem/D                     (DP, https://codeforces.com/contest/1096/submission/106954920)
https://codeforces.com/contest/1152/problem/D                      (Important, Problem based on Recursive patterns, can be solved using Recursion or DP)
https://www.codechef.com/APRIL21B/problems/MEXSTR                      (Nice constructive problem, https://www.codechef.com/viewsolution/44966730)
https://leetcode.com/problems/last-stone-weight-ii/                   (observation, abs(a-b) minimum, https://pastebin.com/BAkcmdA5, https://pastebin.com/gFGTkpia)
https://leetcode.com/problems/palindrome-partitioning-iii/              (same like Kitten and photos codeforces, https://pastebin.com/AAb7CadN)
https://leetcode.com/problems/palindrome-partitioning-iv/          (same as above problem, but with some precomputation is required, longest palindrome substring, https://pastebin.com/yUE81XP1)
https://leetcode.com/problems/palindrome-partitioning-ii/                (Longest palindrome, https://pastebin.com/5FgebtRN)
https://codeforces.com/contest/1447/problem/D                         (Most profit substring, https://codeforces.com/contest/1447/submission/113043762)
https://codeforces.com/contest/1511/problem/E                       (Dp, contribution, important, Grid number of ways, https://codeforces.com/contest/1511/submission/113126475)
https://codeforces.com/contest/1509/problem/C                         (NOTE: we can't solve this greedily, simple dp, sorting, https://codeforces.com/contest/1509/submission/113308769)
https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/            (maximum submatrix sum, kadane)
https://codeforces.com/contest/1525/problem/D                                       (dp, 2D, greedy, https://codeforces.com/contest/1525/submission/116551443)          
https://www.geeksforgeeks.org/number-of-permutation-with-k-inversions/        (DP, permuation, counting, inversion)


